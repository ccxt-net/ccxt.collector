using CCXT.Collector.Bithumb;
using CCXT.Collector.Library;
using CCXT.Collector.Service;
using CCXT.Collector.Indicator;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace CCXT.Collector.Samples.Exchanges
{
    /// <summary>
    /// Bithumb Exchange Sample Implementation (Korean Exchange)
    /// Demonstrates real-time market data analysis and payment coin features
    /// </summary>
    public class BithumbSample
    {
        private readonly BithumbWebSocketClient _client;
        private readonly Dictionary<string, BithumbMarketData> _marketData;
        private readonly PaymentCoinAnalyzer _paymentAnalyzer;
        private CancellationTokenSource _cancellationTokenSource;

        public BithumbSample()
        {
            _client = new BithumbWebSocketClient();
            _marketData = new Dictionary<string, BithumbMarketData>();
            _paymentAnalyzer = new PaymentCoinAnalyzer();
            _cancellationTokenSource = new CancellationTokenSource();
        }

        /// <summary>
        /// Run Bithumb sample with payment coin focus
        /// </summary>
        public async Task RunAsync()
        {
            Console.WriteLine("===========================================");
            Console.WriteLine("     Bithumb Exchange Sample (ÎπóÏç∏)");
            Console.WriteLine("===========================================\n");

            Console.WriteLine("Select operation mode:");
            Console.WriteLine("1. Payment Coin Analysis (Í≤∞Ï†ú ÏΩîÏù∏ Î∂ÑÏÑù)");
            Console.WriteLine("2. Market Depth Analysis (ÏãúÏû• ÍπäÏù¥ Î∂ÑÏÑù)");
            Console.WriteLine("3. Arbitrage Opportunity Scanner");
            Console.WriteLine("4. Market Making Simulator");
            Console.WriteLine("5. Risk Management Dashboard");
            Console.WriteLine("6. Full Trading System Demo");
            Console.WriteLine("0. Exit");

            Console.Write("\nYour choice: ");
            var choice = Console.ReadLine();

            try
            {
                switch (choice)
                {
                    case "1":
                        await RunPaymentCoinAnalysis();
                        break;
                    case "2":
                        await RunMarketDepthAnalysis();
                        break;
                    case "3":
                        await RunArbitrageScanner();
                        break;
                    case "4":
                        await RunMarketMakingSimulator();
                        break;
                    case "5":
                        await RunRiskManagementDashboard();
                        break;
                    case "6":
                        await RunFullTradingSystem();
                        break;
                    case "0":
                        return;
                    default:
                        Console.WriteLine("Invalid choice");
                        break;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
            finally
            {
                await Cleanup();
            }
        }

        /// <summary>
        /// Payment coin analysis (Bithumb speciality)
        /// </summary>
        private async Task RunPaymentCoinAnalysis()
        {
            Console.WriteLine("\nüí≥ Starting Bithumb Payment Coin Analysis...\n");

            // Bithumb payment coins
            var paymentCoins = new[] { "KRW-BTC", "KRW-ETH", "KRW-XRP", "KRW-EOS", "KRW-BCH" };

            _client.OnTickerReceived += (ticker) =>
            {
                _paymentAnalyzer.UpdateTicker(ticker);

                Console.Clear();
                Console.WriteLine("BITHUMB PAYMENT COIN ANALYSIS (Í≤∞Ï†ú ÏΩîÏù∏ Î∂ÑÏÑù)");
                Console.WriteLine($"Time: {DateTime.Now:HH:mm:ss} KST");
                Console.WriteLine(new string('=', 110));

                // Display payment coin metrics
                Console.WriteLine($"{"ÏΩîÏù∏",-10} {"ÌòÑÏû¨Í∞Ä",15} {"24h Î≥ÄÎèô",10} {"Í≤∞Ï†ú ÏÜçÎèÑ",12} {"ÏàòÏàòÎ£å",10} {"ÌôúÏö©ÎèÑ",10} {"Ï†êÏàò",8}");
                Console.WriteLine(new string('-', 110));

                var metrics = _paymentAnalyzer.GetPaymentMetrics();
                foreach (var metric in metrics.OrderByDescending(m => m.Value.Score))
                {
                    var data = metric.Value;
                    var changeColor = data.Change24h >= 0 ? ConsoleColor.Green : ConsoleColor.Red;

                    Console.Write($"{metric.Key,-10} ");
                    Console.Write($"‚Ç©{data.Price,14:N0} ");

                    Console.ForegroundColor = changeColor;
                    Console.Write($"{(data.Change24h >= 0 ? "‚ñ≤" : "‚ñº")}{Math.Abs(data.Change24h),8:F2}% ");
                    Console.ResetColor();

                    Console.Write($"{data.Speed,12} ");
                    Console.Write($"{data.Fee,10} ");
                    Console.Write($"{data.Adoption,10} ");

                    // Score with color coding
                    var scoreColor = data.Score > 80 ? ConsoleColor.Green :
                                    data.Score > 60 ? ConsoleColor.Yellow :
                                    ConsoleColor.Red;
                    Console.ForegroundColor = scoreColor;
                    Console.WriteLine($"{data.Score,8:F1}");
                    Console.ResetColor();
                }

                // Payment coin insights
                Console.WriteLine("\nüìä Í≤∞Ï†ú ÏΩîÏù∏ Ïù∏ÏÇ¨Ïù¥Ìä∏:");
                var insights = _paymentAnalyzer.GetInsights();
                foreach (var insight in insights)
                {
                    Console.WriteLine($"  ‚Ä¢ {insight}");
                }

                // Transaction volume analysis
                Console.WriteLine("\nüí∞ Í±∞Îûò Î∂ÑÏÑù:");
                var txAnalysis = _paymentAnalyzer.GetTransactionAnalysis();
                Console.WriteLine($"  Ï¥ù Í±∞ÎûòÎüâ: {txAnalysis.TotalVolume / 100_000_000:N0}ÏñµÏõê");
                Console.WriteLine($"  ÌèâÍ∑† Í±∞Îûò ÌÅ¨Í∏∞: ‚Ç©{txAnalysis.AvgTransactionSize:N0}");
                Console.WriteLine($"  ÎåÄÎüâ Í±∞Îûò ÎπÑÏú®: {txAnalysis.LargeTransactionRatio:F1}%");

                // Best payment coin recommendation
                var bestCoin = _paymentAnalyzer.GetBestPaymentCoin();
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine($"\nüèÜ Ï∂îÏ≤ú Í≤∞Ï†ú ÏΩîÏù∏: {bestCoin.Symbol} (Ï†êÏàò: {bestCoin.Score:F1})");
                Console.WriteLine($"   Ïù¥Ïú†: {bestCoin.Reason}");
                Console.ResetColor();

                Console.WriteLine("\nPress 'Q' to quit...");
            };

            await _client.ConnectAsync();
            foreach (var coin in paymentCoins)
            {
                await _client.SubscribeTicker(coin);
                await Task.Delay(50);
            }

            await WaitForExit();
        }

        /// <summary>
        /// Market depth analysis
        /// </summary>
        private async Task RunMarketDepthAnalysis()
        {
            Console.WriteLine("\nüìä Starting Bithumb Market Depth Analysis...\n");

            var depthAnalyzer = new MarketDepthAnalyzer();

            _client.OnOrderbookReceived += (orderbook) =>
            {
                depthAnalyzer.UpdateOrderbook(orderbook);
                var analysis = depthAnalyzer.Analyze();

                Console.Clear();
                Console.WriteLine($"BITHUMB MARKET DEPTH ANALYSIS - {orderbook.symbol}");
                Console.WriteLine($"Time: {DateTime.Now:HH:mm:ss} KST");
                Console.WriteLine(new string('=', 100));

                // Depth visualization
                Console.WriteLine("\nüìä ÏãúÏû• ÍπäÏù¥ ÏãúÍ∞ÅÌôî:");
                DrawDepthChart(orderbook);

                // Key metrics
                Console.WriteLine("\nüìà ÌïµÏã¨ ÏßÄÌëú:");
                Console.WriteLine($"  Ï§ëÍ∞ÑÍ∞Ä: ‚Ç©{analysis.MidPrice:N0}");
                Console.WriteLine($"  Ïä§ÌîÑÎ†àÎìú: ‚Ç©{analysis.Spread:N0} ({analysis.SpreadPercent:F4}%)");
                Console.WriteLine($"  10Ìò∏Í∞Ä ÍπäÏù¥: Îß§Ïàò {analysis.BidDepth10:F4} / Îß§ÎèÑ {analysis.AskDepth10:F4}");
                Console.WriteLine($"  Ïú†ÎèôÏÑ± Ï†êÏàò: {analysis.LiquidityScore:F1}/100");

                // Support and resistance levels
                Console.WriteLine("\nüéØ ÏßÄÏßÄ/Ï†ÄÌï≠ Î†àÎ≤®:");
                foreach (var level in analysis.SupportLevels.Take(3))
                {
                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.WriteLine($"  ÏßÄÏßÄ: ‚Ç©{level.Price:N0} (Í∞ïÎèÑ: {level.Strength:F1})");
                }
                foreach (var level in analysis.ResistanceLevels.Take(3))
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine($"  Ï†ÄÌï≠: ‚Ç©{level.Price:N0} (Í∞ïÎèÑ: {level.Strength:F1})");
                }
                Console.ResetColor();

                // Order flow imbalance
                Console.WriteLine("\nüíπ Ï£ºÎ¨∏ ÌùêÎ¶Ñ:");
                DrawOrderFlowBar(analysis.OrderFlowImbalance);
                Console.WriteLine($"  ÎåÄÎüâ Îß§Ïàò Ï£ºÎ¨∏: {analysis.LargeBuyOrders}Í∞ú");
                Console.WriteLine($"  ÎåÄÎüâ Îß§ÎèÑ Ï£ºÎ¨∏: {analysis.LargeSellOrders}Í∞ú");

                // Market microstructure
                Console.WriteLine("\nüî¨ ÏãúÏû• ÎØ∏ÏãúÍµ¨Ï°∞:");
                Console.WriteLine($"  Í∞ÄÍ≤© ÌÅ¥Îü¨Ïä§ÌÑ∞: {string.Join(", ", analysis.PriceClusters.Select(c => $"‚Ç©{c:N0}"))}");
                Console.WriteLine($"  Ï£ºÎ¨∏ ÏßëÏ§ëÎèÑ: {analysis.OrderConcentration:F2}");
                Console.WriteLine($"  ÏãúÏû• Ìö®Ïú®ÏÑ±: {analysis.MarketEfficiency:F1}%");

                // Trading opportunity
                if (analysis.TradingOpportunity != null)
                {
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine($"\nüí° Í±∞Îûò Í∏∞Ìöå: {analysis.TradingOpportunity}");
                    Console.ResetColor();
                }

                Console.WriteLine("\nPress 'Q' to quit...");
            };

            await _client.ConnectAsync();
            await _client.SubscribeOrderbook("KRW-BTC");

            await WaitForExit();
        }

        /// <summary>
        /// Arbitrage opportunity scanner
        /// </summary>
        private async Task RunArbitrageScanner()
        {
            Console.WriteLine("\nüí± Starting Bithumb Arbitrage Scanner...\n");

            var arbScanner = new ArbitrageScanner();

            _client.OnTickerReceived += (ticker) =>
            {
                arbScanner.UpdatePrice("Bithumb", ticker.symbol, ticker.lastPrice);

                Console.Clear();
                Console.WriteLine("BITHUMB ARBITRAGE OPPORTUNITY SCANNER");
                Console.WriteLine($"Time: {DateTime.Now:HH:mm:ss} KST");
                Console.WriteLine(new string('=', 110));

                var opportunities = arbScanner.FindOpportunities();

                if (opportunities.Any())
                {
                    Console.WriteLine($"{"Ï¢ÖÎ™©",-10} {"ÎπóÏç∏",15} {"ÌÉÄÍ±∞ÎûòÏÜå",15} {"Ï∞®Ïù¥",12} {"ÏàòÏùµÎ•†",10} {"ÏòàÏÉÅÏàòÏùµ",15} {"Î¶¨Ïä§ÌÅ¨",10}");
                    Console.WriteLine(new string('-', 110));

                    foreach (var opp in opportunities.OrderByDescending(o => o.ProfitPercent))
                    {
                        var profitColor = opp.ProfitPercent > 2 ? ConsoleColor.Green :
                                        opp.ProfitPercent > 1 ? ConsoleColor.Yellow :
                                        ConsoleColor.White;

                        Console.Write($"{opp.Symbol,-10} ");
                        Console.Write($"‚Ç©{opp.BithumbPrice,14:N0} ");
                        Console.Write($"‚Ç©{opp.OtherPrice,14:N0} ");
                        Console.Write($"‚Ç©{opp.PriceDiff,11:N0} ");

                        Console.ForegroundColor = profitColor;
                        Console.Write($"{opp.ProfitPercent,9:F2}% ");
                        Console.ResetColor();

                        Console.Write($"‚Ç©{opp.EstimatedProfit,14:N0} ");

                        var riskColor = opp.Risk == "Low" ? ConsoleColor.Green :
                                       opp.Risk == "Medium" ? ConsoleColor.Yellow :
                                       ConsoleColor.Red;
                        Console.ForegroundColor = riskColor;
                        Console.WriteLine($"{opp.Risk,10}");
                        Console.ResetColor();
                    }

                    // Summary
                    Console.WriteLine($"\nüìä Ï∞®ÏùµÍ±∞Îûò ÏöîÏïΩ:");
                    Console.WriteLine($"  Î∞úÍ≤¨Îêú Í∏∞Ìöå: {opportunities.Count}Í∞ú");
                    Console.WriteLine($"  ÌèâÍ∑† ÏàòÏùµÎ•†: {opportunities.Average(o => o.ProfitPercent):F2}%");
                    Console.WriteLine($"  ÏµúÎåÄ ÏàòÏùµÎ•†: {opportunities.Max(o => o.ProfitPercent):F2}%");

                    // Execution strategy
                    var bestOpp = opportunities.OrderByDescending(o => o.ProfitPercent).First();
                    Console.WriteLine($"\nüéØ Ïã§Ìñâ Ï†ÑÎûµ:");
                    Console.WriteLine($"  1. {bestOpp.Symbol} ÎπóÏç∏ÏóêÏÑú Îß§Ïàò (‚Ç©{bestOpp.BithumbPrice:N0})");
                    Console.WriteLine($"  2. ÌÉÄÍ±∞ÎûòÏÜåÎ°ú Ï†ÑÏÜ° (ÏòàÏÉÅ ÏãúÍ∞Ñ: {bestOpp.TransferTime})");
                    Console.WriteLine($"  3. ÌÉÄÍ±∞ÎûòÏÜåÏóêÏÑú Îß§ÎèÑ (‚Ç©{bestOpp.OtherPrice:N0})");
                    Console.WriteLine($"  4. ÏòàÏÉÅ ÏàúÏàòÏùµ: ‚Ç©{bestOpp.NetProfit:N0}");
                }
                else
                {
                    Console.WriteLine("\nÌòÑÏû¨ Ï∞®ÏùµÍ±∞Îûò Í∏∞ÌöåÍ∞Ä ÏóÜÏäµÎãàÎã§.");
                    Console.WriteLine("Í≥ÑÏÜç Î™®ÎãàÌÑ∞ÎßÅ Ï§ë...");
                }

                // Market conditions
                Console.WriteLine($"\nüåê ÏãúÏû• ÏÉÅÌô©:");
                var conditions = arbScanner.GetMarketConditions();
                foreach (var condition in conditions)
                {
                    Console.WriteLine($"  ‚Ä¢ {condition}");
                }

                Console.WriteLine("\nPress 'Q' to quit...");
            };

            await _client.ConnectAsync();
            var symbols = new[] { "KRW-BTC", "KRW-ETH", "KRW-XRP", "KRW-EOS", "KRW-BCH" };
            foreach (var symbol in symbols)
            {
                await _client.SubscribeTicker(symbol);
                await Task.Delay(50);
            }

            await WaitForExit();
        }

        /// <summary>
        /// Market making simulator
        /// </summary>
        private async Task RunMarketMakingSimulator()
        {
            Console.WriteLine("\nü§ñ Starting Bithumb Market Making Simulator...\n");

            var mmSimulator = new MarketMakingSimulator();

            _client.OnOrderbookReceived += (orderbook) =>
            {
                var strategy = mmSimulator.UpdateAndCalculate(orderbook);

                Console.Clear();
                Console.WriteLine("BITHUMB MARKET MAKING SIMULATOR");
                Console.WriteLine($"Time: {DateTime.Now:HH:mm:ss} KST | Symbol: {orderbook.symbol}");
                Console.WriteLine(new string('=', 100));

                // Current positions
                Console.WriteLine("\nüìä ÌòÑÏû¨ Ìè¨ÏßÄÏÖò:");
                Console.WriteLine($"  ÏûîÍ≥†: ‚Ç©{mmSimulator.Balance:N0}");
                Console.WriteLine($"  Î≥¥Ïú†Îüâ: {mmSimulator.Position:F8} BTC");
                Console.WriteLine($"  Ï¥ù Í∞ÄÏπò: ‚Ç©{mmSimulator.TotalValue:N0}");
                Console.WriteLine($"  Ïã§ÌòÑ ÏàòÏùµ: ‚Ç©{mmSimulator.RealizedPnL:N0}");
                Console.WriteLine($"  ÎØ∏Ïã§ÌòÑ ÏàòÏùµ: ‚Ç©{mmSimulator.UnrealizedPnL:N0}");

                // Active orders
                Console.WriteLine("\nüìã ÌôúÏÑ± Ï£ºÎ¨∏:");
                Console.WriteLine($"{"Ïú†Ìòï",8} {"Í∞ÄÍ≤©",15} {"ÏàòÎüâ",12} {"ÏÉÅÌÉú",10} {"ÏàòÏùµÎ•†",10}");
                Console.WriteLine(new string('-', 100));

                foreach (var order in mmSimulator.ActiveOrders)
                {
                    var color = order.Side == "Buy" ? ConsoleColor.Green : ConsoleColor.Red;
                    Console.ForegroundColor = color;
                    Console.WriteLine($"{order.Side,8} ‚Ç©{order.Price,14:N0} {order.Quantity,12:F8} {order.Status,10} {order.ProfitTarget,9:F2}%");
                    Console.ResetColor();
                }

                // Strategy parameters
                Console.WriteLine("\n‚öôÔ∏è Ï†ÑÎûµ ÌååÎùºÎØ∏ÌÑ∞:");
                Console.WriteLine($"  Ïä§ÌîÑÎ†àÎìú: {strategy.SpreadBps:F1} bps");
                Console.WriteLine($"  Ï£ºÎ¨∏ ÌÅ¨Í∏∞: {strategy.OrderSize:F8} BTC");
                Console.WriteLine($"  ÏµúÎåÄ Ìè¨ÏßÄÏÖò: {strategy.MaxPosition:F8} BTC");
                Console.WriteLine($"  Î¶¨Ïä§ÌÅ¨ ÌïúÎèÑ: ‚Ç©{strategy.RiskLimit:N0}");
                Console.WriteLine($"  Ïû¨Ï°∞Ï†ï Ï£ºÍ∏∞: {strategy.RebalanceInterval}Ï¥à");

                // Performance metrics
                Console.WriteLine("\nüìà ÏÑ±Í≥º ÏßÄÌëú:");
                Console.WriteLine($"  Ï¥ù Í±∞Îûò: {mmSimulator.TotalTrades}Ìöå");
                Console.WriteLine($"  ÏÑ±Í≥µÎ•†: {mmSimulator.WinRate:F1}%");
                Console.WriteLine($"  ÌèâÍ∑† ÏàòÏùµ: ‚Ç©{mmSimulator.AvgProfit:N0}");
                Console.WriteLine($"  ÏµúÎåÄ ÏÜêÏã§: ‚Ç©{mmSimulator.MaxDrawdown:N0}");
                Console.WriteLine($"  ÏÉ§ÌîÑ ÎπÑÏú®: {mmSimulator.SharpeRatio:F2}");

                // Risk indicators
                Console.WriteLine("\n‚ö†Ô∏è Î¶¨Ïä§ÌÅ¨ ÏßÄÌëú:");
                DrawRiskMeter(mmSimulator.RiskLevel);
                Console.WriteLine($"  Î≥ÄÎèôÏÑ±: {mmSimulator.Volatility:F2}%");
                Console.WriteLine($"  Ïú†ÎèôÏÑ± Î¶¨Ïä§ÌÅ¨: {mmSimulator.LiquidityRisk}");
                Console.WriteLine($"  Ìè¨ÏßÄÏÖò Î¶¨Ïä§ÌÅ¨: {mmSimulator.PositionRisk}");

                // Trading signals
                if (strategy.Signals.Any())
                {
                    Console.WriteLine("\nüí° Í±∞Îûò Ïã†Ìò∏:");
                    foreach (var signal in strategy.Signals)
                    {
                        Console.WriteLine($"  ‚Ä¢ {signal}");
                    }
                }

                Console.WriteLine("\nPress 'Q' to quit...");
            };

            await _client.ConnectAsync();
            await _client.SubscribeOrderbook("KRW-BTC");

            await WaitForExit();
        }

        /// <summary>
        /// Risk management dashboard
        /// </summary>
        private async Task RunRiskManagementDashboard()
        {
            Console.WriteLine("\nüõ°Ô∏è Starting Bithumb Risk Management Dashboard...\n");

            var riskManager = new RiskManager();

            _client.OnTickerReceived += (ticker) =>
            {
                riskManager.UpdateMarketData(ticker);
            };

            _client.OnOrderbookReceived += (orderbook) =>
            {
                riskManager.UpdateOrderbook(orderbook);

                Console.Clear();
                Console.WriteLine("BITHUMB RISK MANAGEMENT DASHBOARD");
                Console.WriteLine($"Time: {DateTime.Now:HH:mm:ss} KST");
                Console.WriteLine(new string('=', 110));

                var riskMetrics = riskManager.CalculateRiskMetrics();

                // Portfolio risk overview
                Console.WriteLine("\nüìä Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Î¶¨Ïä§ÌÅ¨:");
                Console.WriteLine($"  Value at Risk (VaR) 95%: ‚Ç©{riskMetrics.VaR95:N0}");
                Console.WriteLine($"  Value at Risk (VaR) 99%: ‚Ç©{riskMetrics.VaR99:N0}");
                Console.WriteLine($"  Expected Shortfall: ‚Ç©{riskMetrics.ExpectedShortfall:N0}");
                Console.WriteLine($"  ÏµúÎåÄ ÏòàÏÉÅ ÏÜêÏã§: ‚Ç©{riskMetrics.MaxExpectedLoss:N0}");

                // Market risk indicators
                Console.WriteLine("\nüìà ÏãúÏû• Î¶¨Ïä§ÌÅ¨:");
                DrawRiskHeatmap(riskMetrics.MarketRisk);
                Console.WriteLine($"  Î≥ÄÎèôÏÑ± (ÏùºÍ∞Ñ): {riskMetrics.DailyVolatility:F2}%");
                Console.WriteLine($"  Î≥ÄÎèôÏÑ± (Ï£ºÍ∞Ñ): {riskMetrics.WeeklyVolatility:F2}%");
                Console.WriteLine($"  Î≤†ÌÉÄ: {riskMetrics.Beta:F2}");
                Console.WriteLine($"  ÏÉÅÍ¥ÄÍ≥ÑÏàò: {riskMetrics.Correlation:F2}");

                // Liquidity risk
                Console.WriteLine("\nüíß Ïú†ÎèôÏÑ± Î¶¨Ïä§ÌÅ¨:");
                Console.WriteLine($"  Ïä¨Î¶¨ÌîºÏßÄ ÏòàÏÉÅ: {riskMetrics.ExpectedSlippage:F2}%");
                Console.WriteLine($"  Ïú†ÎèôÏÑ± Ï†êÏàò: {riskMetrics.LiquidityScore:F1}/100");
                Console.WriteLine($"  ÏãúÏû• Ï∂©Í≤©: {riskMetrics.MarketImpact:F2}%");
                Console.WriteLine($"  Ï≤≠ÏÇ∞ ÏãúÍ∞Ñ: {riskMetrics.LiquidationTime}");

                // Operational risk
                Console.WriteLine("\n‚öôÔ∏è Ïö¥ÏòÅ Î¶¨Ïä§ÌÅ¨:");
                Console.WriteLine($"  ÏãúÏä§ÌÖú Í∞ÄÎèôÎ•†: {riskMetrics.SystemUptime:F1}%");
                Console.WriteLine($"  API ÏùëÎãµ ÏãúÍ∞Ñ: {riskMetrics.ApiLatency}ms");
                Console.WriteLine($"  Ïò§Î•òÏú®: {riskMetrics.ErrorRate:F2}%");
                Console.WriteLine($"  Î∞±ÏóÖ ÏÉÅÌÉú: {riskMetrics.BackupStatus}");

                // Risk limits and alerts
                Console.WriteLine("\nüö® Î¶¨Ïä§ÌÅ¨ ÌïúÎèÑ:");
                foreach (var limit in riskMetrics.RiskLimits)
                {
                    var usage = limit.CurrentUsage / limit.Limit * 100;
                    var color = usage > 80 ? ConsoleColor.Red :
                               usage > 60 ? ConsoleColor.Yellow :
                               ConsoleColor.Green;

                    Console.ForegroundColor = color;
                    Console.WriteLine($"  {limit.Name}: {limit.CurrentUsage:N0} / {limit.Limit:N0} ({usage:F1}%)");
                    Console.ResetColor();
                }

                // Risk mitigation recommendations
                if (riskMetrics.Recommendations.Any())
                {
                    Console.WriteLine("\nüí° Î¶¨Ïä§ÌÅ¨ ÏôÑÌôî Í∂åÍ≥†ÏÇ¨Ìï≠:");
                    foreach (var rec in riskMetrics.Recommendations)
                    {
                        Console.WriteLine($"  ‚Ä¢ {rec}");
                    }
                }

                Console.WriteLine("\nPress 'Q' to quit...");
            };

            await _client.ConnectAsync();
            await _client.SubscribeTicker("KRW-BTC");
            await _client.SubscribeOrderbook("KRW-BTC");

            await WaitForExit();
        }

        /// <summary>
        /// Full trading system demo
        /// </summary>
        private async Task RunFullTradingSystem()
        {
            Console.WriteLine("\nüöÄ Starting Bithumb Full Trading System Demo...\n");
            Console.WriteLine("This comprehensive demo showcases all trading features.");
            Console.WriteLine("Each module will run for demonstration...\n");

            var tradingSystem = new TradingSystem();

            // Initialize all components
            _client.OnTickerReceived += (ticker) =>
            {
                tradingSystem.ProcessTicker(ticker);
            };

            _client.OnOrderbookReceived += (orderbook) =>
            {
                tradingSystem.ProcessOrderbook(orderbook);
            };

            _client.OnTradeReceived += (trade) =>
            {
                tradingSystem.ProcessTrade(trade);

                // Update display
                DisplayTradingSystem(tradingSystem);
            };

            await _client.ConnectAsync();

            // Subscribe to multiple data streams
            var symbols = new[] { "KRW-BTC", "KRW-ETH", "KRW-XRP" };
            foreach (var symbol in symbols)
            {
                await _client.SubscribeTicker(symbol);
                await _client.SubscribeOrderbook(symbol);
                await _client.SubscribeTrades(symbol);
                await Task.Delay(50);
            }

            await WaitForExit();
        }

        // Helper methods
        private void DisplayTradingSystem(TradingSystem system)
        {
            Console.Clear();
            Console.WriteLine("BITHUMB INTEGRATED TRADING SYSTEM");
            Console.WriteLine($"Time: {DateTime.Now:HH:mm:ss} KST");
            Console.WriteLine(new string('=', 120));

            // System status
            Console.WriteLine($"\nüü¢ ÏãúÏä§ÌÖú ÏÉÅÌÉú: {system.Status}");
            Console.WriteLine($"   Í∞ÄÎèô ÏãúÍ∞Ñ: {system.Uptime}");
            Console.WriteLine($"   Ï≤òÎ¶¨Îêú Ïù¥Î≤§Ìä∏: {system.ProcessedEvents:N0}");

            // Active strategies
            Console.WriteLine("\nüìã ÌôúÏÑ± Ï†ÑÎûµ:");
            foreach (var strategy in system.ActiveStrategies)
            {
                var statusColor = strategy.IsActive ? ConsoleColor.Green : ConsoleColor.Yellow;
                Console.ForegroundColor = statusColor;
                Console.WriteLine($"  ‚Ä¢ {strategy.Name}: {strategy.Status} (PnL: ‚Ç©{strategy.PnL:N0})");
                Console.ResetColor();
            }

            // Portfolio summary
            Console.WriteLine("\nüíº Ìè¨Ìä∏Ìè¥Î¶¨Ïò§:");
            Console.WriteLine($"  Ï¥ù ÏûêÏÇ∞: ‚Ç©{system.TotalAssets:N0}");
            Console.WriteLine($"  ÏùºÏùº ÏàòÏùµ: ‚Ç©{system.DailyPnL:N0} ({system.DailyReturn:F2}%)");
            Console.WriteLine($"  ÏõîÍ∞Ñ ÏàòÏùµ: ‚Ç©{system.MonthlyPnL:N0} ({system.MonthlyReturn:F2}%)");

            // Recent trades
            Console.WriteLine("\nüìà ÏµúÍ∑º Í±∞Îûò:");
            foreach (var trade in system.RecentTrades.Take(5))
            {
                var color = trade.Side == "Buy" ? ConsoleColor.Green : ConsoleColor.Red;
                Console.ForegroundColor = color;
                Console.WriteLine($"  {trade.Time:HH:mm:ss} {trade.Symbol} {trade.Side} {trade.Quantity:F8} @ ‚Ç©{trade.Price:N0}");
                Console.ResetColor();
            }

            Console.WriteLine("\nPress 'Q' to quit...");
        }

        private void DrawDepthChart(SOrderBook orderbook)
        {
            var maxQuantity = Math.Max(
                orderbook.bids.Take(10).Max(b => b.quantity),
                orderbook.asks.Take(10).Max(a => a.quantity)
            );

            // Draw asks
            for (int i = Math.Min(4, orderbook.asks.Count - 1); i >= 0; i--)
            {
                var ask = orderbook.asks[i];
                var barLength = (int)(ask.quantity / maxQuantity * 30);
                Console.ForegroundColor = ConsoleColor.Red;
                Console.Write($"  {ask.price,12:N0} ");
                Console.Write(new string('‚ñà', barLength));
                Console.WriteLine($" {ask.quantity:F4}");
            }

            Console.ResetColor();
            Console.WriteLine($"  ------------ SPREAD ------------");

            // Draw bids
            for (int i = 0; i < Math.Min(5, orderbook.bids.Count); i++)
            {
                var bid = orderbook.bids[i];
                var barLength = (int)(bid.quantity / maxQuantity * 30);
                Console.ForegroundColor = ConsoleColor.Green;
                Console.Write($"  {bid.price,12:N0} ");
                Console.Write(new string('‚ñà', barLength));
                Console.WriteLine($" {bid.quantity:F4}");
            }
            Console.ResetColor();
        }

        private void DrawOrderFlowBar(double imbalance)
        {
            Console.Write("  ");
            var position = (int)((imbalance + 100) / 10); // -100 to 100 -> 0 to 20

            for (int i = 0; i < 20; i++)
            {
                if (i < 10)
                    Console.ForegroundColor = ConsoleColor.Red;
                else
                    Console.ForegroundColor = ConsoleColor.Green;

                if (i == position)
                    Console.Write("‚óÜ");
                else
                    Console.Write("‚îÄ");
            }
            Console.ResetColor();
            Console.WriteLine($" ({imbalance:F1}%)");
        }

        private void DrawRiskMeter(double riskLevel)
        {
            Console.Write("  Î¶¨Ïä§ÌÅ¨ ÏàòÏ§Ä: [");
            var fillLength = (int)(riskLevel / 5);
            var color = riskLevel > 60 ? ConsoleColor.Red :
                       riskLevel > 30 ? ConsoleColor.Yellow :
                       ConsoleColor.Green;

            Console.ForegroundColor = color;
            Console.Write(new string('‚ñà', fillLength));
            Console.Write(new string('‚ñë', 20 - fillLength));
            Console.ResetColor();
            Console.WriteLine($"] {riskLevel:F0}%");
        }

        private void DrawRiskHeatmap(Dictionary<string, double> risks)
        {
            foreach (var risk in risks)
            {
                var color = risk.Value > 70 ? ConsoleColor.Red :
                           risk.Value > 40 ? ConsoleColor.Yellow :
                           ConsoleColor.Green;

                Console.Write($"  {risk.Key}: ");
                Console.ForegroundColor = color;
                Console.WriteLine($"{new string('‚ñà', (int)(risk.Value / 10))} {risk.Value:F0}%");
                Console.ResetColor();
            }
        }

        private async Task WaitForExit()
        {
            await Task.Run(() =>
            {
                while (!_cancellationTokenSource.Token.IsCancellationRequested)
                {
                    if (Console.KeyAvailable)
                    {
                        var key = Console.ReadKey(true);
                        if (key.KeyChar == 'q' || key.KeyChar == 'Q')
                        {
                            _cancellationTokenSource.Cancel();
                            break;
                        }
                    }
                    Thread.Sleep(100);
                }
            });
        }

        private async Task Cleanup()
        {
            await _client.DisconnectAsync();
            _cancellationTokenSource?.Dispose();
        }
    }

    // Supporting classes for Bithumb-specific features
    public class BithumbMarketData
    {
        public decimal Price { get; set; }
        public decimal Change24h { get; set; }
        public decimal Volume { get; set; }
        public DateTime LastUpdate { get; set; }
    }

    public class PaymentCoinAnalyzer
    {
        private Dictionary<string, PaymentCoinMetric> _metrics = new Dictionary<string, PaymentCoinMetric>();

        public void UpdateTicker(STickerItem ticker)
        {
            var symbol = ticker.symbol.Replace("KRW-", "");
            if (!_metrics.ContainsKey(symbol))
                _metrics[symbol] = new PaymentCoinMetric();

            _metrics[symbol].Price = ticker.lastPrice;
            _metrics[symbol].Change24h = ticker.changePercent;
            _metrics[symbol].Volume = ticker.volume * ticker.lastPrice;
            CalculatePaymentScore(symbol);
        }

        private void CalculatePaymentScore(string symbol)
        {
            var metric = _metrics[symbol];
            
            // Payment coin characteristics
            metric.Speed = GetTransactionSpeed(symbol);
            metric.Fee = GetTransactionFee(symbol);
            metric.Adoption = GetAdoptionLevel(symbol);

            // Calculate overall score
            var speedScore = metric.Speed == "Îπ†Î¶Ñ" ? 30 : metric.Speed == "Î≥¥ÌÜµ" ? 20 : 10;
            var feeScore = metric.Fee == "ÎÇÆÏùå" ? 30 : metric.Fee == "Î≥¥ÌÜµ" ? 20 : 10;
            var adoptionScore = metric.Adoption == "ÎÜíÏùå" ? 40 : metric.Adoption == "Î≥¥ÌÜµ" ? 25 : 10;

            metric.Score = speedScore + feeScore + adoptionScore;
        }

        private string GetTransactionSpeed(string symbol)
        {
            return symbol switch
            {
                "XRP" => "Îπ†Î¶Ñ",
                "BCH" => "Îπ†Î¶Ñ",
                "ETH" => "Î≥¥ÌÜµ",
                "BTC" => "ÎäêÎ¶º",
                _ => "Î≥¥ÌÜµ"
            };
        }

        private string GetTransactionFee(string symbol)
        {
            return symbol switch
            {
                "XRP" => "ÎÇÆÏùå",
                "BCH" => "ÎÇÆÏùå",
                "ETH" => "ÎÜíÏùå",
                "BTC" => "ÎÜíÏùå",
                _ => "Î≥¥ÌÜµ"
            };
        }

        private string GetAdoptionLevel(string symbol)
        {
            return symbol switch
            {
                "BTC" => "ÎÜíÏùå",
                "ETH" => "ÎÜíÏùå",
                "XRP" => "Î≥¥ÌÜµ",
                _ => "ÎÇÆÏùå"
            };
        }

        public Dictionary<string, PaymentCoinMetric> GetPaymentMetrics() => _metrics;

        public List<string> GetInsights()
        {
            var insights = new List<string>();

            var bestSpeed = _metrics.Where(m => m.Value.Speed == "Îπ†Î¶Ñ").Select(m => m.Key);
            if (bestSpeed.Any())
                insights.Add($"Îπ†Î•∏ Ï†ÑÏÜ°: {string.Join(", ", bestSpeed)}");

            var lowFee = _metrics.Where(m => m.Value.Fee == "ÎÇÆÏùå").Select(m => m.Key);
            if (lowFee.Any())
                insights.Add($"ÎÇÆÏùÄ ÏàòÏàòÎ£å: {string.Join(", ", lowFee)}");

            var highAdoption = _metrics.Where(m => m.Value.Adoption == "ÎÜíÏùå").Select(m => m.Key);
            if (highAdoption.Any())
                insights.Add($"ÎÜíÏùÄ Ï±ÑÌÉùÎ•†: {string.Join(", ", highAdoption)}");

            return insights;
        }

        public TransactionAnalysis GetTransactionAnalysis()
        {
            return new TransactionAnalysis
            {
                TotalVolume = _metrics.Values.Sum(m => m.Volume),
                AvgTransactionSize = _metrics.Values.Average(m => m.Volume / 1000),
                LargeTransactionRatio = 15.5m // Simulated
            };
        }

        public PaymentCoinRecommendation GetBestPaymentCoin()
        {
            var best = _metrics.OrderByDescending(m => m.Value.Score).FirstOrDefault();
            return new PaymentCoinRecommendation
            {
                Symbol = best.Key,
                Score = best.Value.Score,
                Reason = $"Îπ†Î•∏ ÏÜçÎèÑ, ÎÇÆÏùÄ ÏàòÏàòÎ£å, {best.Value.Adoption} Ï±ÑÌÉùÎ•†"
            };
        }
    }

    public class PaymentCoinMetric
    {
        public decimal Price { get; set; }
        public decimal Change24h { get; set; }
        public decimal Volume { get; set; }
        public string Speed { get; set; }
        public string Fee { get; set; }
        public string Adoption { get; set; }
        public double Score { get; set; }
    }

    public class TransactionAnalysis
    {
        public decimal TotalVolume { get; set; }
        public decimal AvgTransactionSize { get; set; }
        public decimal LargeTransactionRatio { get; set; }
    }

    public class PaymentCoinRecommendation
    {
        public string Symbol { get; set; }
        public double Score { get; set; }
        public string Reason { get; set; }
    }

    public class MarketDepthAnalyzer
    {
        private SOrderBookItem _lastOrderbook;

        public void UpdateOrderbook(SOrderBookItem orderbook)
        {
            _lastOrderbook = orderbook;
        }

        public MarketDepthAnalysis Analyze()
        {
            if (_lastOrderbook == null)
                return new MarketDepthAnalysis();

            return new MarketDepthAnalysis
            {
                MidPrice = (_lastOrderbook.bids[0].price + _lastOrderbook.asks[0].price) / 2,
                Spread = _lastOrderbook.asks[0].price - _lastOrderbook.bids[0].price,
                SpreadPercent = ((_lastOrderbook.asks[0].price - _lastOrderbook.bids[0].price) / _lastOrderbook.bids[0].price) * 100,
                BidDepth10 = _lastOrderbook.bids.Take(10).Sum(b => b.quantity),
                AskDepth10 = _lastOrderbook.asks.Take(10).Sum(a => a.quantity),
                LiquidityScore = CalculateLiquidityScore(),
                SupportLevels = FindSupportLevels(),
                ResistanceLevels = FindResistanceLevels(),
                OrderFlowImbalance = CalculateOrderFlowImbalance(),
                LargeBuyOrders = _lastOrderbook.bids.Count(b => b.quantity > _lastOrderbook.bids.Average(x => x.quantity) * 3),
                LargeSellOrders = _lastOrderbook.asks.Count(a => a.quantity > _lastOrderbook.asks.Average(x => x.quantity) * 3),
                PriceClusters = FindPriceClusters(),
                OrderConcentration = CalculateOrderConcentration(),
                MarketEfficiency = CalculateMarketEfficiency(),
                TradingOpportunity = DetectTradingOpportunity()
            };
        }

        private double CalculateLiquidityScore()
        {
            // Simplified liquidity score calculation
            return 75.5;
        }

        private List<PriceLevel> FindSupportLevels()
        {
            // Simplified support level detection
            return new List<PriceLevel>
            {
                new PriceLevel { Price = 90000000, Strength = 85 },
                new PriceLevel { Price = 89500000, Strength = 70 },
                new PriceLevel { Price = 89000000, Strength = 60 }
            };
        }

        private List<PriceLevel> FindResistanceLevels()
        {
            // Simplified resistance level detection
            return new List<PriceLevel>
            {
                new PriceLevel { Price = 91000000, Strength = 80 },
                new PriceLevel { Price = 91500000, Strength = 75 },
                new PriceLevel { Price = 92000000, Strength = 65 }
            };
        }

        private double CalculateOrderFlowImbalance()
        {
            if (_lastOrderbook == null) return 0;

            var bidVolume = _lastOrderbook.bids.Sum(b => b.quantity);
            var askVolume = _lastOrderbook.asks.Sum(a => a.quantity);
            var total = bidVolume + askVolume;

            return total > 0 ? (double)((bidVolume - askVolume) / total * 100) : 0;
        }

        private List<decimal> FindPriceClusters()
        {
            // Simplified price cluster detection
            return new List<decimal> { 90000000, 90500000, 91000000 };
        }

        private double CalculateOrderConcentration()
        {
            // Simplified order concentration calculation
            return 0.45;
        }

        private double CalculateMarketEfficiency()
        {
            // Simplified market efficiency calculation
            return 85.5;
        }

        private string DetectTradingOpportunity()
        {
            var imbalance = CalculateOrderFlowImbalance();
            if (imbalance > 30)
                return "Strong buy pressure detected - consider long position";
            if (imbalance < -30)
                return "Strong sell pressure detected - consider short position";
            return null;
        }
    }

    public class MarketDepthAnalysis
    {
        public decimal MidPrice { get; set; }
        public decimal Spread { get; set; }
        public decimal SpreadPercent { get; set; }
        public decimal BidDepth10 { get; set; }
        public decimal AskDepth10 { get; set; }
        public double LiquidityScore { get; set; }
        public List<PriceLevel> SupportLevels { get; set; } = new List<PriceLevel>();
        public List<PriceLevel> ResistanceLevels { get; set; } = new List<PriceLevel>();
        public double OrderFlowImbalance { get; set; }
        public int LargeBuyOrders { get; set; }
        public int LargeSellOrders { get; set; }
        public List<decimal> PriceClusters { get; set; } = new List<decimal>();
        public double OrderConcentration { get; set; }
        public double MarketEfficiency { get; set; }
        public string TradingOpportunity { get; set; }
    }

    public class PriceLevel
    {
        public decimal Price { get; set; }
        public double Strength { get; set; }
    }

    // Additional supporting classes for other features...
    public class ArbitrageScanner
    {
        private Dictionary<string, Dictionary<string, decimal>> _prices = new Dictionary<string, Dictionary<string, decimal>>();

        public void UpdatePrice(string exchange, string symbol, decimal price)
        {
            if (!_prices.ContainsKey(symbol))
                _prices[symbol] = new Dictionary<string, decimal>();
            _prices[symbol][exchange] = price;
        }

        public List<ArbitrageOpportunity> FindOpportunities()
        {
            // Simplified arbitrage detection
            return new List<ArbitrageOpportunity>
            {
                new ArbitrageOpportunity
                {
                    Symbol = "BTC",
                    BithumbPrice = 90000000,
                    OtherPrice = 91000000,
                    PriceDiff = 1000000,
                    ProfitPercent = 1.1m,
                    EstimatedProfit = 1000000,
                    Risk = "Low",
                    TransferTime = "10Î∂Ñ",
                    NetProfit = 900000
                }
            };
        }

        public List<string> GetMarketConditions()
        {
            return new List<string>
            {
                "Ï†ÑÏ≤¥ ÏãúÏû• Î≥ÄÎèôÏÑ±: Î≥¥ÌÜµ",
                "Í±∞ÎûòÎüâ: Ï¶ùÍ∞Ä Ï∂îÏÑ∏",
                "ÎÑ§Ìä∏ÏõåÌÅ¨ ÏàòÏàòÎ£å: ÏïàÏ†ï"
            };
        }
    }

    public class ArbitrageOpportunity
    {
        public string Symbol { get; set; }
        public decimal BithumbPrice { get; set; }
        public decimal OtherPrice { get; set; }
        public decimal PriceDiff { get; set; }
        public decimal ProfitPercent { get; set; }
        public decimal EstimatedProfit { get; set; }
        public string Risk { get; set; }
        public string TransferTime { get; set; }
        public decimal NetProfit { get; set; }
    }

    public class MarketMakingSimulator
    {
        public decimal Balance { get; set; } = 100000000; // 100M KRW
        public decimal Position { get; set; } = 0;
        public decimal TotalValue { get; set; }
        public decimal RealizedPnL { get; set; }
        public decimal UnrealizedPnL { get; set; }
        public List<SimulatedOrder> ActiveOrders { get; set; } = new List<SimulatedOrder>();
        public int TotalTrades { get; set; }
        public double WinRate { get; set; } = 65;
        public decimal AvgProfit { get; set; } = 50000;
        public decimal MaxDrawdown { get; set; } = -500000;
        public double SharpeRatio { get; set; } = 1.85;
        public double RiskLevel { get; set; } = 35;
        public double Volatility { get; set; } = 12.5;
        public string LiquidityRisk { get; set; } = "Low";
        public string PositionRisk { get; set; } = "Medium";

        public MarketMakingStrategy UpdateAndCalculate(SOrderBookItem orderbook)
        {
            // Simplified market making strategy
            return new MarketMakingStrategy
            {
                SpreadBps = 25,
                OrderSize = 0.1m,
                MaxPosition = 5,
                RiskLimit = 5000000,
                RebalanceInterval = 60,
                Signals = new List<string> { "Spread widening detected", "Place limit orders" }
            };
        }
    }

    public class SimulatedOrder
    {
        public string Side { get; set; }
        public decimal Price { get; set; }
        public decimal Quantity { get; set; }
        public string Status { get; set; }
        public double ProfitTarget { get; set; }
    }

    public class MarketMakingStrategy
    {
        public double SpreadBps { get; set; }
        public decimal OrderSize { get; set; }
        public decimal MaxPosition { get; set; }
        public decimal RiskLimit { get; set; }
        public int RebalanceInterval { get; set; }
        public List<string> Signals { get; set; } = new List<string>();
    }

    public class RiskManager
    {
        public void UpdateMarketData(STickerItem ticker) { }
        public void UpdateOrderbook(SOrderBookItem orderbook) { }

        public RiskMetrics CalculateRiskMetrics()
        {
            // Simplified risk metrics
            return new RiskMetrics
            {
                VaR95 = 5000000,
                VaR99 = 8000000,
                ExpectedShortfall = 10000000,
                MaxExpectedLoss = 15000000,
                DailyVolatility = 3.5,
                WeeklyVolatility = 8.2,
                Beta = 1.15,
                Correlation = 0.85,
                ExpectedSlippage = 0.15,
                LiquidityScore = 82,
                MarketImpact = 0.05,
                LiquidationTime = "5Î∂Ñ",
                SystemUptime = 99.9,
                ApiLatency = 45,
                ErrorRate = 0.01,
                BackupStatus = "Ï†ïÏÉÅ",
                MarketRisk = new Dictionary<string, double>
                {
                    { "Í∞ÄÍ≤© Î¶¨Ïä§ÌÅ¨", 45 },
                    { "Î≥ÄÎèôÏÑ± Î¶¨Ïä§ÌÅ¨", 60 },
                    { "Ïú†ÎèôÏÑ± Î¶¨Ïä§ÌÅ¨", 30 }
                },
                RiskLimits = new List<RiskLimit>
                {
                    new RiskLimit { Name = "Ìè¨ÏßÄÏÖò ÌïúÎèÑ", CurrentUsage = 3000000, Limit = 5000000 },
                    new RiskLimit { Name = "ÏÜêÏã§ ÌïúÎèÑ", CurrentUsage = 800000, Limit = 1000000 }
                },
                Recommendations = new List<string>
                {
                    "Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Ï∂ïÏÜå Í∂åÍ≥†",
                    "Ïä§ÌÜ±Î°úÏä§ ÏÑ§Ï†ï Í∞ïÌôî"
                }
            };
        }
    }

    public class RiskMetrics
    {
        public decimal VaR95 { get; set; }
        public decimal VaR99 { get; set; }
        public decimal ExpectedShortfall { get; set; }
        public decimal MaxExpectedLoss { get; set; }
        public double DailyVolatility { get; set; }
        public double WeeklyVolatility { get; set; }
        public double Beta { get; set; }
        public double Correlation { get; set; }
        public double ExpectedSlippage { get; set; }
        public double LiquidityScore { get; set; }
        public double MarketImpact { get; set; }
        public string LiquidationTime { get; set; }
        public double SystemUptime { get; set; }
        public int ApiLatency { get; set; }
        public double ErrorRate { get; set; }
        public string BackupStatus { get; set; }
        public Dictionary<string, double> MarketRisk { get; set; }
        public List<RiskLimit> RiskLimits { get; set; }
        public List<string> Recommendations { get; set; }
    }

    public class RiskLimit
    {
        public string Name { get; set; }
        public decimal CurrentUsage { get; set; }
        public decimal Limit { get; set; }
    }

    public class TradingSystem
    {
        public string Status { get; set; } = "Active";
        public string Uptime { get; set; } = "2h 35m";
        public int ProcessedEvents { get; set; } = 15432;
        public decimal TotalAssets { get; set; } = 150000000;
        public decimal DailyPnL { get; set; } = 2500000;
        public double DailyReturn { get; set; } = 1.67;
        public decimal MonthlyPnL { get; set; } = 45000000;
        public double MonthlyReturn { get; set; } = 30;
        public List<TradingStrategy> ActiveStrategies { get; set; } = new List<TradingStrategy>
        {
            new TradingStrategy { Name = "Market Making", IsActive = true, Status = "Running", PnL = 1500000 },
            new TradingStrategy { Name = "Arbitrage", IsActive = true, Status = "Monitoring", PnL = 800000 },
            new TradingStrategy { Name = "Momentum", IsActive = false, Status = "Paused", PnL = 200000 }
        };
        public List<SystemTrade> RecentTrades { get; set; } = new List<SystemTrade>();

        public void ProcessTicker(STickerItem ticker) { }
        public void ProcessOrderbook(SOrderBookItem orderbook) { }
        public void ProcessTrade(SCompleteOrderItem trade)
        {
            ProcessedEvents++;
            RecentTrades.Add(new SystemTrade
            {
                Time = DateTime.Now,
                Symbol = trade.symbol,
                Side = trade.sideType == "B" ? "Buy" : "Sell",
                Quantity = trade.quantity,
                Price = trade.price
            });
            if (RecentTrades.Count > 10) RecentTrades.RemoveAt(0);
        }
    }

    public class TradingStrategy
    {
        public string Name { get; set; }
        public bool IsActive { get; set; }
        public string Status { get; set; }
        public decimal PnL { get; set; }
    }

    public class SystemTrade
    {
        public DateTime Time { get; set; }
        public string Symbol { get; set; }
        public string Side { get; set; }
        public decimal Quantity { get; set; }
        public decimal Price { get; set; }
    }
}